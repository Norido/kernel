<h1>CVE 2017-6074</h1>
<h3>Tóm tắt lỗi</h3>
<pre><code>apt-get install linux-source-4.4.0=4.4.0-31.50  
tar jxf /usr/src/linux-source-4.4.0.tar.bz2
</code></pre>
<ul>
<li>File: net/dccp/input.c<pre><code class="language-c">line <span class="hljs-number">605</span>
<span class="hljs-keyword">if</span> (dh-&gt;dccph_type == DCCP_PKT_REQUEST) {
  <span class="hljs-keyword">if</span> (inet_csk(sk)-&gt;icsk_af_ops-&gt;conn_request(sk, skb) &lt; <span class="hljs-number">0</span>)
      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
  <span class="hljs-keyword">goto</span> discard;
}
line <span class="hljs-number">702</span>
discard:
  __kfree_skb(skb);
</code></pre>
=&gt; SKB sẽ đc free nếu như dccp_v6_conn_request trả về success.</li>
<li>File: net/dccp/ipv6.c<pre><code>line 346
    if (ipv6_opt_accepted(sk, skb, IP6CB(skb)) ||
        np-&gt;rxopt.bits.rxinfo || np-&gt;rxopt.bits.rxoinfo ||
        np-&gt;rxopt.bits.rxhlim || np-&gt;rxopt.bits.rxohlim) {
        atomic_inc(&amp;skb-&gt;users);
        ireq-&gt;pktopts = skb;
    }
line 519
    if (*own_req &amp;&amp; ireq-&gt;pktopts) {
        newnp-&gt;pktoptions = skb_clone(ireq-&gt;pktopts, GFP_ATOMIC);
        consume_skb(ireq-&gt;pktopts);
        ireq-&gt;pktopts = NULL;
        if (newnp-&gt;pktoptions)
            skb_set_owner_r(newnp-&gt;pktoptions, newsk);
    }
</code></pre>
=&gt; ireq-&gt;pktopts = skb sau đó lại gọi consume_skb(ireq-&gt;pktopts); bên trong consume_skb sẽ thực thi lệnh __kfree_skb(newnp-&gt;pktoptions); tương đương với __kfree_skb(skb);</li>
<li>Ở đây xảy ra lỗi double free.</li>
</ul>
<h3>Khai thác lỗi</h3>
<ul>
<li>Dựa trên lỗi double free này ta sẽ sử dũng kỹ thuật use after free như sau:
<ul>
<li>__kfree_skb(skb); //Giải phóng vùng nhớ 0x69 =&gt; 0x69 đang rỗi</li>
<li>kmalloc(object1); //Cấp cho object1 vùng nhớ 0x69</li>
<li>__kfree_skb(skb); //Giải phóng vùng nhớ 0x69 =&gt; 0x69 đang rỗi</li>
<li>kmalloc(object2); //Cấp cho object2 vùng nhớ 0x69</li>
</ul>
</li>
<li>Con trỏ object1 trỏ lên object2 (Dangling pointers) giờ đây ta chỉ cần kiếm cặp object phù hợp để có thể điều kiển được con trỏ lệnh và truyền tham số là có thể get được root vì ubuntu từ bản 14 trở đi mặc định địa chỉ kernel là cố định (nếu bật KASLR vẫn bypass được sẽ giới thiệu sau).
<ul>
<li>Cặp object phù hợp: khi thay đổi data trong object này sẽ tương ứng với data trong object còn lại mà data trong object còn lại là data có thể giúp chúng ta điều khiển con trỏ lệnh, chèn tham số.</li>
</ul>
</li>
<li>Tuy nhiên ở đây khá là dễ dàng khi một object là skb (có trường call_back) và object còn lại ta có thể điều khiển được size và data bên trong tùy ý. (bên dưới)
<ul>
<li>Object điều khiển được size và data
<ul>
<li>/net/socket.c<pre><code>line 1999
int __sys_sendmmsg(int fd, struct mmsghdr __user *mmsg, unsigned int vlen, unsigned int flags)
...
ctl_buf = sock_kmalloc(sock-&gt;sk, ctl_len, GFP_KERNEL);
</code></pre>
</li>
</ul>
</li>
<li>Object skb:
<ul>
<li>__kfree_skb sẽ gọi hàm skb_release_data trong /net/core/skbuff.c
<pre><code>line 582
static void skb_release_data(struct sk_buff *skb)
{
    struct skb_shared_info *shinfo = skb_shinfo(skb);
    int i;

    if (skb-&gt;cloned &amp;&amp;
        atomic_sub_return(skb-&gt;nohdr ? (1 &lt;&lt; SKB_DATAREF_SHIFT) + 1 : 1,
                  &amp;shinfo-&gt;dataref))
        return;

    for (i = 0; i &lt; shinfo-&gt;nr_frags; i++)
        __skb_frag_unref(&amp;shinfo-&gt;frags[i]);

    /*
     * If skb buf is from userspace, we need to notify the caller
     * the lower device DMA has done;
     */
    if (shinfo-&gt;tx_flags &amp; SKBTX_DEV_ZEROCOPY) {
        struct ubuf_info *uarg;

        uarg = shinfo-&gt;destructor_arg;
        if (uarg-&gt;callback)
            uarg-&gt;callback(uarg, true);
    }

    if (shinfo-&gt;frag_list)
        kfree_skb_list(shinfo-&gt;frag_list);

    skb_free_head(skb);
}
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>Chỉ điều khiển được con trỏ lệnh là chưa đủ vì để tắt SMAP SMEP ta cần thực hiện native_write_cr4(giá_trị_mong_muốn). Đối với bản POC gốc của tác giả: <a href="https://github.com/xairy/kernel-exploits/blob/master/CVE-2017-6074/poc.c">https://github.com/xairy/kernel-exploits/blob/master/CVE-2017-6074/poc.c</a> tác giả sử dụng thêm 1 object khác có thể điều khiển đc tham số truyền vào khi call_back tuy nhiên không ổn định có thể gây crash server sau khi thực hiện nên đã được anlpth fix lại. Ta thấy hàm khi gọi hàm call_back phía trên arg đầu tiên truyền vào chính là địa chỉ của uarg nên ta có thể điều khiển địa chỉ của uarg sẽ điều khiển được arg đầu tiên (sử dụng: mmap để thêm 1 vùng nhớ bất kì).</li>
</ul>
<h3>int main(int argc, char * argv [])</h3>
<ul>
<li>Sử dụng use after free để điều khiển con trỏ lệnh và truyền tham số thứ nhất như sau:
<ul>
<li>native_write_cr4(0x406e0); //DISABLE SMAP SMEP</li>
</ul>
</li>
<li>Sau đó call_back kernel lên userland thực thi lệnh commit_creds(prepare_kernel_cred(0)); sẽ cho process hiện tại quyền root.</li>
<li>Để bypass được KASLR thì lần đầu ta call_back vào thẳng userland sẽ tạo ra mini crash không ảnh hưởng đến toàn kernel. Lúc đó log crash sẽ nằm ở /dev/kmsg đọc log này ta sẽ tính đc offset giữa địa chỉ kernel có KASLR và địa chỉ kernel không có KASLR. Các hàm còn lại chỉ cần tính theo offset này.</li>
<li>Lưu ý để sử dụng được mã khai khác trên cần update shinfo_offset (nếu source linux có thay đổi) và offset các hàm trong kernel hiện tại. Để có offset kernel hiện tại xem 2 hình sau:</li>
<li>Add repository ...</li>
<pre><code>wget -O - http://ddebs.ubuntu.com/dbgsym-release-key.asc | sudo apt-key add -
codename=$(lsb_release -c | awk  '{print $2}')
sudo tee /etc/apt/sources.list.d/ddebs.list << EOF
deb http://ddebs.ubuntu.com/ ${codename}      main restricted universe multiverse
deb http://ddebs.ubuntu.com/ ${codename}-security main restricted universe multiverse
deb http://ddebs.ubuntu.com/ ${codename}-updates  main restricted universe multiverse
deb http://ddebs.ubuntu.com/ ${codename}-proposed main restricted universe multiverse
EOF

sudo apt-get update
</code></pre>
<img src="https://gitlab.visc.com/anlpth/my-awesome-project/raw/ef8ccefa0c4942713b60f6562018af3157674c9b/CVE-2017-6074/IMG/2.png"/>
<img src="https://gitlab.visc.com/anlpth/my-awesome-project/raw/ef8ccefa0c4942713b60f6562018af3157674c9b/CVE-2017-6074/IMG/1.png"/>
</ul>
