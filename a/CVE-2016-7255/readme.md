<h1>Tóm tắt lỗi</h1>Hàm xxxNextWindow có một lệnh ASM cho phép ta OR một ô nhớ bất kì&nbsp;với 4.<br><h1>Chi tiết lỗi</h1><img alt="" src="https://gitlab.visc.com/anlpth/my-awesome-project/raw/d7b6c58e6245108fe05f6d143ad0bd12e390eece/CVE-2017-7255/IMG/1.png"><br>Line 305: V12 sẽ được return bởi GetNextQueueWindow rồi sau đó tại line 266 dword [[v12 + 0xC0] + 0x28] sẽ OR với 0x4.<br>Như vậy nếu có thể control đc v12+0xC0 ta có thể OR bất kì ô nhớ DWORD nào với 0x4.&nbsp;NtSetWindowLongPtr cho phép ta control được&nbsp;<span>v12+0xC0.<br></span><h1>Khai thác lỗi</h1>Chỉ OR được 1 bit trong 1 byte bất kỳ không cho ta nhiều khả năng để EXPLOIT. Tuy nhiên OR ngay bit 2 trong 1 byte bất kì thì lại khác. Vì trong PTE (page table entry) có một&nbsp;địa chỉ&nbsp;0xFFFFF6FB7DBEDF68 là PML4_SELF_REF (page map level 4 self reference) địa chỉ này dùng để tự map chính nó lên Physical Memory. Tại địa chỉ này bit 2 quyết định vùng nhớ này là USER/SUPERVISOR. Nếu bit 2 = 0 thì PAGE này (size 0x1000) USER-MOD không thể ACCESS. May mắn hơn nữa&nbsp;PML4_SELF_REF&nbsp;luôn nằm ở&nbsp;<span>0xFFFFF6FB7DBEDF68&nbsp; (Win 7).<br><br></span>Chúng ta thật sự không cần thiết phải set USER cho&nbsp;0xFFFFF6FB7DBEDF68&nbsp;&nbsp;tuy nhiên trong mã khai thác của tôi thì lại sử dụng vì để chắc chắn&nbsp;rằng tôi đã set USER cho các vùng nhớ khác bằng cách đọc giá trị tại&nbsp;X (FFFFF6FFFFFFFFF8&gt;X&gt;FFFFF68000000000) check bit 2 đã bằng 1 chưa? (X dùng để map địa chỉ Logic sang Physic).<br>Tại sao PAGE chỉ có SIZE là 0x1000 nhưng nếu set USER cho địa chỉ&nbsp;0xFFFFF6FB7DBEDF68 lại có khả năng đọc ngoài PAGE? PTE.md<br><br>Kịch bản:<br>(FFFFF6FFFFFFFFF8&gt;X&gt;FFFFF68000000000<span>)<br></span>(FFFFF6FFFFFFFFF8&gt;X&gt;FFFFF68000000000)<br><ol><li>OR [0xFFFFF6FB7DBEDF68], 0x4</li><li>Tìm HalDispatchTable_address</li><li>Tìm X nào sẽ map&nbsp;HalDispatchTable_address lên Physical Memory (FFFFF6FFFFFFFFF8&gt;X&gt;FFFFF68000000000)</li><li>OR [X], 0x4</li><li>Y nào sẽ map&nbsp;0xFFFFFFFFFFD04000 (HAL_HEAP) lên Physical Memory&nbsp;</li><li>OR [Y], 0x4</li><li>Memcpy&nbsp;privilege shellcode lên Y</li><li>MOV [HalDispatchTable_address+0x8], Y</li><li>Gọi&nbsp;NtQueryIntervalProfile</li></ol>Bước 1 cho phép ta check ở 4 vs 6.<br>Bước 2&nbsp;HalDispatchTable không quan trọng quan trọng là&nbsp;HalDispatchTable+0x8&nbsp;vì nơi này lưu pointer của&nbsp;NtQueryIntervalProfile. Khi gọi&nbsp;NtQueryIntervalProfile thì KERNEL sẽ Call [<span>HalDispatchTable+0x8].<br>Bước 3 Cách tính ở trong PTE.md<br>Bước 4 Cần phải OR cả 4 PAGE LEVEL.</span>